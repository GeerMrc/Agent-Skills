误解的痛：一位网友重构 Agent Skills 的全过程
2025-12-29 13:19·隽月星辰
最近看到Reddit上一位开发者的分享帖，讲述了他对Claude Code的Agent Skills从完全误解到彻底重构的经历。这位开发者在Agent Skills发布后就立即开始构建，两周内创建了多个庞大的技能文件，每个都超过800行，甚至有一个达到了1131行。他的仓库迅速获得了400+星标，但每次激活多个相关技能时，上下文窗口就会爆炸式增长到5000-7000行。经过两周的困惑和调试，他才意识到问题所在：把技能当作了文档dump。这种痛苦而真实的踩坑经历，以及他最终的解决方案——渐进式披露架构，对任何使用大语言模型工具的开发者都有重要启发。


你将看到什么
上下文爆炸的惨痛教训
三层架构的渐进式披露
从文档思维到工作流思维
重构前后的数据对比
200行规则的实战验证
技能设计的核心原则
社区反馈的多元视角
可复制的重构建议
01
上下文爆炸的惨痛教训
这位开发者在Agent Skills（一种Claude Code的扩展机制）于10月16日发布后立即投入构建。按照最初的思路，他认为应该把所有相关信息都塞进单个SKILL.md文件中，让智能体在一开始就获得完整信息。于是，他创建了cloudflare技能（1131行）、shadcn-ui技能（850行）、nextjs技能（900行）和chrome-devtools技能（超过1200行）。仓库很快就获得了400多个星标，表面看起来进展顺利。

但实际问题很快暴露：每当Claude Code激活多个相关技能时，上下文窗口就会急剧膨胀。加载5-7个技能意味着5000-7000行代码和文档瞬间涌入上下文窗口。更糟糕的是，这些内容中大约90%在大多数情况下都是无关的，智能体需要花费大量计算资源来筛选这些噪音。

最讽刺的是，这位开发者自己也在skill-creator技能中记录过"渐进式披露"原则，但当时他并没有真正理解这个原则在实践中的含义。他后来承认："我甚至在自己的技能创建技能中记录了‘渐进式披露’原则。我把它写下来了，只是不明白它在实践中到底意味着什么。"


02
三层架构的渐进式披露
在经历了两周的调试和困惑后，开发者终于找到了解决方案：渐进式披露的三层加载系统。这个架构的核心思想是"按需加载"，而不是"一次性全量加载"。

第一层：元数据（总是加载） 这层只包含YAML frontmatter，大约100个单词。它提供了足够的信息让Claude判断技能是否相关，但绝不包含具体实现细节。这就像是一本书的封面和简介，让你决定是否要继续阅读。

第二层：SKILL.md入口点（技能激活时加载） 这一层限制在最多200行，包含技能概览、快速入门指南和导航地图。关键是，它指向引用文件但不包含引用文件的内容。想象一下餐厅的菜单——列出所有菜品和简短描述，但具体烹饪方法需要单独询问厨师。

第三层：引用文件和脚本（按需加载） 每个引用文件控制在200-300行，专注于单一主题的详细文档。只有当Claude确定需要特定信息时才会加载这些文件。这就像当你点了某道菜后，厨师才会去准备具体食材和烹饪步骤。

这种分层设计的妙处在于，它模拟了人类解决问题的自然流程：先判断相关性，再了解概览，最后深入研究细节。每个步骤都小而专注，避免了信息过载。


03
从文档思维到工作流思维
开发者意识到，根本问题不在于技术实现，而在于思维模式。他最初把Agent Skills当作文档来对待——为每个工具创建详细的文档dump。但这种做法完全误解了技能的本质。

错误的文档思维：

认为每个工具都需要自己的技能
技能=工具的完整文档
目标是提供所有可能用到的信息
结果：36个独立的工具特定技能，每个都是信息孤岛
正确的工作流思维：

技能=开发工作流中的具体能力
按工作流阶段组织技能，而不是按工具
目标是让智能体在特定情境下具备特定能力
结果：20个工作流能力组
例如，devops技能不是"Cloudflare文档"，而是"部署无服务器函数的能力"；ui-styling技能不是"Tailwind文档"，而是"设计一致界面的能力"。这种思维转变导致了自然的技能合并：从36个工具特定技能合并为20个工作流能力组，包括devops、web-frameworks、ui-styling、databases等。

开发者总结道："技能不是文档。它们是开发工作流中激活的特定能力。每个技能教会Claude如何执行特定的开发任务，而不是工具做什么。"

这种思维转变带来了更深层次的理解。文档是被动的参考材料，而技能是主动的工作流知识。当你需要写测试时，激活code-review技能；调试生产问题时，激活sequential-thinking技能；部署基础设施时，激活devops技能；构建UI时，激活ui-styling和web-frameworks技能。

每个技能对应开发过程中的一个具体时刻，而不是一个工具的完整知识库。这种视角让技能设计变得更有针对性——不是"我需要告诉Claude关于Cloudflare的一切"，而是"当Claude需要部署无服务器函数时，它需要知道什么"。


04
重构前后的数据对比
真正的改变需要数据支撑。这位开发者不仅分享了理念，还提供了详细的量化对比，让我们能够清楚地看到重构带来的实际效果。

单个技能重构效果： claude-code技能是重构的典型案例。重构前，它是一个870行的庞大文件；重构后，变成了181行的SKILL.md入口点加上13个引用文件。这相当于减少了79%的初始加载内容，或者说提升了4.8倍的token效率。

整体架构重构效果： 在完成第一阶段和第二阶段的重组后，原先分散在36个独立技能中的约15,000行代码（大约120K到300K tokens）被重新组织。新的架构包括20个聚焦的技能组，总计2,200行初始加载内容加上45个引用文件。

重构前的激活devops上下文意味着立即加载2,500多行内容，其中大部分从未被使用。重构后，同样的工作流只需加载几百行高度相关的内容。

性能指标对比：

激活时间：从约500毫秒降低到少于100毫秒
上下文溢出风险：从频繁发生变为缓慢积累
相关信息比例：从约10%提升到约90%
这些数据清楚地表明，渐进式披露不仅是理论上的优化，更是实践中显著提升性能的关键。


05
200行规则的实战验证
在分享中，开发者反复强调"200行规则"，并表示这个数字不是随意选择的，而是基于大量实验验证的结果。

为什么是200行？ 200行大约是大型语言模型能够高效扫描以决定下一步加载多少内容的极限。保持入口点在200行以内，Claude可以快速完成三个关键决策：

理解技能提供什么能力
决定需要读取哪个引用文件
加载该文件（另外200-300行）
这样，总上下文消耗控制在400-700行高度相关的内容，而不是1,000多行混合相关性的内容。

开发者坦言："200行规则不是建议。它是快速导航和上下文污泥之间的区别。"他甚至开玩笑说这个规则是他自己编造的（基于实验），但经过充分测试，不仅仅是假设。

规则的严格执行： 他提出了一个明确的准则："每个超过200行的技能都应该被重构。没有例外。如果你不能在200行内融入核心指令，那么你在入口点放了太多东西。"

这个规则也暴露了一个常见的误解：开发者最初把references/目录视为"可选的额外文档"，但实际上，引用文件才是真正工作发生的地方。SKILL.md只是一个地图，告诉你有哪些地方可以去，但不包含这些地方的具体内容。

如何测试和验证： 开发者建议了一个简单的测试方法："测试冷启动：清除你的上下文，激活技能，然后测量。如果它在首次激活时加载超过500行，你就做错了。"

这种基于度量的方法很重要，因为它提供了客观的反馈，而不是主观的感觉。4.8倍的token效率改进不是边际改善，而是"有时工作"和"可靠工作"之间的区别。

评论区中有用户询问这个200行规则的来源，开发者坦诚回答："我不想让你失望，但我编造了它（基于我的实验）但我完全测试了它，不仅仅是假设。"这种诚实反而增强了建议的可信度——规则源于实践验证，而不是盲目遵循文档。


06
技能设计的核心原则
从这个经历中，可以提炼出几个Agent Skills设计的核心原则，这些原则适用于任何使用大语言模型扩展机制的开发者。

1. 渐进式披露不是可选的 这应该是技能设计的默认方法。技能应该像好的教学一样，先提供概览，再深入细节。每个层级都应该有明确的目的：元数据用于相关性判断，入口点用于技能理解，引用文件用于具体实现。

2. 技能组织按能力，不按工具 不要为每个工具创建单独的技能，而要为每个工作流阶段创建技能。思考"在这个开发阶段需要什么能力"，而不是"关于这个工具需要知道什么"。

3. 引用文件是一等公民 references/目录不应该被视为次要的补充材料。相反，大部分具体内容应该放在引用文件中。SKILL.md文件应该简洁，主要作为导航地图存在。

4. 200行入口点规则 尽可能将SKILL.md入口点控制在200行以内。如果做不到，很可能意味着技能设计有问题——可能是试图在入口点包含太多内容，或者是技能范围定义得太宽。

5. 测试冷启动性能 定期清除上下文并测试技能的冷启动性能。如果初始加载超过500行，就需要重新考虑技能设计。性能指标不撒谎——它们是设计质量的最客观反馈。

6. 避免文档思维陷阱 警惕将技能写成文档的自然倾向。大语言模型有强烈的偏见，倾向于将markdown文件写成文档，包含大量琐碎的例子、明显的反面案例和入门级的填充内容。需要明确指示模型：这不是文档，而是为自身设计的基于文件的上下文缓存。

评论区的一位用户指出："一般来说，关键的是永远不要让Claude认为它在写‘文档’——默认情况下，对于任何markdown文件，它都会这样做。帮助它理解，它写的不是文档，而是为自身精心设计的基于文件的上下文缓存。"这个观察非常准确，点出了技能设计的心理模型问题。

7. 度量和验证 不要依赖感觉，要依赖数据。度量token效率、激活时间、相关信息比例。4.8倍的改进不是边际的，而是根本性的差异。


07
社区反馈的多元视角
原帖的评论区提供了丰富多样的视角，既有支持赞同，也有批评质疑，还有补充建议，形成了一个完整的讨论生态。

支持与赞赏： 许多用户表示感谢分享，认为这些经验很有价值。一位用户评论道："非常有帮助！！！感谢你整理这一切，你本可以保持沉默，不必担心所有的抨击。人们有时候就是很傻。继续前进吧！"另一位用户表示："这正是一直让我每天浏览Reddit的那种帖子。"

批评与质疑： 也有用户对原帖的写作风格提出批评。一位用户直言："如果还有其他人觉得这种AI生成的废话令人讨厌，这里有一个没有废话的重写版本..."并提供了简洁版总结。另一位用户说："我没有读完整个帖子，但在前三段之后就清楚你没有阅读技能如何工作的文档。所有在这里评论的机器人也没有这样做。"

实用性质疑： 有用户质疑使用大语言模型写短文的必要性："我一生都无法理解为什么人们用LLM写短散文。代码生成很棒，因为通常瓶颈是你的手指打字，一个好的提示可以生成比提示输入多100倍以上的代码。但是一小段英语散文？为什么？"

补充建议和经验分享： 评论区也包含了许多有价值的补充。一位用户分享了自己使用skill-creator技能的经验："我只想说，使用内置的技能构建器技能来构建你的技能，而不是尝试手动编码，所有这些痛苦都可以避免。技能构建器包含有关技能设计最佳实践的说明，如渐进式披露、引用文件和使用脚本将处理卸载到代码环境而不是LLM做消耗上下文的工作。"

另一位用户指出了模型偏见问题："一般来说，关键的是永远不要让Claude认为它在写‘文档’——默认情况下，对于任何markdown文件，它都会这样做。它有一种非常强烈和持久的偏见，倾向于用琐碎的例子、明显和无数不应该做的例子，以及初学者/教程级别的填充或通用和明显的指导来膨胀markdown文件——通常倾向于螺旋式地转向安全剧场（可能与Claude Code的‘实时转向’不断注入关于安全和恶意代码风险的提醒有关）。"

写作风格讨论： 有趣的是，关于写作风格的讨论成为了一个子话题。有用户表示："只有机器人阅读和评论这样格式化的帖子。如果你有什么要说的，就像人类一样写作。"另一位用户补充："我和你一样。我写了十年的技术文档。我认为在能够以易于阅读和理解复杂主题的方式写作方面，有一点技巧。现在我使用Claude Code。我用它在我们进行的过程中更新Jira和Confluence中的文档。如果它添加了不易阅读或不清晰的东西，我会让它回去重做，直到它容易阅读为止。"


08
可复制的重构建议
基于这个案例的经验教训，我们可以总结出一套可操作的重构建议，适用于任何面临类似问题的开发者。

第一步：审计现有技能 检查你的.claude/skills/目录。列出所有技能，记录每个SKILL.md文件的行数。重点关注超过200行的文件。计算激活典型工作流所需技能时的总行数，了解当前上下文负载。

第二步：重新思考技能组织 不要问"关于这个工具我需要什么信息？"，而是问"在这个工作流阶段需要什么能力？"。开始将相关工具合并到工作流能力组中。例如，将Cloudflare、Docker、GCloud合并到devops组，将Next.js、Turborepo合并到web-frameworks组。

第三步：实施三层架构 为每个技能组创建三层结构：

精简的YAML frontmatter（<100词）
SKILL.md入口点（≤200行）
引用文件（每个200-300行，专注单一主题）
第四步：重构内容 将详细内容从SKILL.md移动到引用文件中。确保SKILL.md主要作为导航地图，告诉Claude有哪些引用文件可用以及何时使用它们。保持语言简洁、指向性明确。

第五步：测试性能 清除上下文缓存，激活技能，测量：

初始加载行数（应该<500行）
激活时间（应该<200ms）
执行典型任务时的总上下文使用
如果性能不达标，进一步精简SKILL.md内容，或将更多细节移动到引用文件。

第六步：建立持续改进流程 定期审查技能设计，确保没有"文档膨胀"。当添加新功能时，首先考虑是否可以作为现有引用文件的补充，而不是扩展SKILL.md。

值得注意的反模式：

避免在技能中使用"关键：执行[x]"或"绝对不要做[y]"这类命令式语言，除非绝对必要
警惕模型添加大量琐碎的要点（膨胀真的很疯狂）
不要过度设计技能——Claude的"第一次猜测"通常比迭代优化更能产生预期行为
最后，记住这位开发者的核心认识："上下文工程不是关于加载更多信息。它是关于在正确的时间加载正确的信息。"这个简单的原则，却是高效使用大语言模型扩展机制的关键。


写在最后
这次重构经历最痛苦的部分不是最初的理解错误——Agent Skills当时才刚发布三周。最痛苦的是，开发者自己记录了解决方案却没有理解它。两周的困惑，一个周末的重构。教训很明确：上下文工程的关键不是加载更多信息，而是在正确的时间加载正确的信息。对于使用大语言模型工具的开发者来说，这个案例提供了从错误中学习的宝贵机会，也提醒我们：最好的解决方案往往就在我们面前，只需要换个角度就能看到。

举报
评论 6

whois1234
赞
当skill 数量膨胀之后，是不是还一样会遇到mcp 带来的token 占用过高的问题？

回复
·
18小时前

隽月星辰
作者
赞
精简每个skill 的description
